<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>常用排序算法 | 张智勇的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">常用排序算法</h1><a id="logo" href="/.">张智勇的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">常用排序算法</h1><div class="post-meta">Jun 17, 2016<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Comments</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本排序算法"><span class="toc-number">1.0.1.</span> <span class="toc-text">基本排序算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高效排序算法"><span class="toc-number">1.0.2.</span> <span class="toc-text">高效排序算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#冒泡排序"><span class="toc-number">2.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思路"><span class="toc-number">2.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码"><span class="toc-number">2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#直接选择排序"><span class="toc-number">3.</span> <span class="toc-text">直接选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-1"><span class="toc-number">3.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码-1"><span class="toc-number">3.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#直接插入排序"><span class="toc-number">4.</span> <span class="toc-text">直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-2"><span class="toc-number">4.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码-2"><span class="toc-number">4.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#希尔排序"><span class="toc-number">5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-3"><span class="toc-number">5.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码-3"><span class="toc-number">5.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#快速排序"><span class="toc-number">6.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-4"><span class="toc-number">6.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码-4"><span class="toc-number">6.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆排序"><span class="toc-number">7.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-5"><span class="toc-number">7.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码-5"><span class="toc-number">7.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#归并排序"><span class="toc-number">8.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路-6"><span class="toc-number">8.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码-6"><span class="toc-number">8.2.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>内部排序算法及其改进算法很多种，但常用的无非以下 7 个。 </p>
<h3 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a><strong>基本排序算法</strong></h3><p>待排序数量不大(&lt; 10K)，平均时间复杂度 <code>O(n^2)</code></p>
<ul>
<li>冒泡排序</li>
<li>直接选择排序</li>
<li>直接插入排序</li>
<li>希尔排序（介于基本排序和高效排序之间）</li>
</ul>
<h3 id="高效排序算法"><a href="#高效排序算法" class="headerlink" title="高效排序算法"></a><strong>高效排序算法</strong></h3><p>待排序数量较大，平均时间复杂度 <code>O(nlogn)</code></p>
<ul>
<li>快速排序</li>
<li>堆排序</li>
<li>归并排序</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>冒泡排序</code>是入门级排序算法，因其实现和理解较为简单而被广泛使用，平均时间复杂度为<code>O(n^2)</code>，由于在排序过程中两两比较，如果相同不作互换，所以是一种<code>稳定</code>的排序算法。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>进行 n 次冒泡，n 为待排序元素个数。每次冒泡产生一个当前未排序元素中最大（小）的元素。    </p>
<ol>
<li>如第一次冒泡，从第一个元素开始，和第二个元素进行比较，如果大于第二个元素，则交换位置。  继续将第二个元素与第三个进行比较，如果大于第三个元素，则交换位置。类似的两两比较直到最后一个元素也被比较。由于每次都把相对大的元素向后推，最终最后一个元素就是最大的。</li>
<li>第 1 步操作完成一个元素的冒泡，而进行第二次冒泡时，只需进行<code>n - 1</code>次比较，因为最大的元素已经排好序了在最后一个。同理，进行第 <code>i</code>次冒泡时，只需进行<code>n - i</code>次比较。由此，进行<code>n</code>次冒泡，每次比较<code>n-i</code>次即可完成冒泡排序。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BubbleSort</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span>(<span class="params"><span class="keyword">int</span> a[]</span>)</span>&#123;</div><div class="line">		<span class="keyword">int</span> n = a.length;</div><div class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; n<span class="number">-1</span>; i++) &#123;	<span class="comment">//进行n次冒泡</span></div><div class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n-i<span class="number">-1</span>;j++) &#123;  <span class="comment">//进行n-i次比较</span></div><div class="line">	            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])  </div><div class="line">	            &#123;<span class="comment">//交换位置</span></div><div class="line">	                <span class="keyword">int</span> tmp = a[j] ; </div><div class="line">	                a[j] = a[j+<span class="number">1</span>] ;  </div><div class="line">	                a[j+<span class="number">1</span>] = tmp;  </div><div class="line">	            &#125;  </div><div class="line">	        &#125;  </div><div class="line">	    &#125;  </div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		bubbleSort(arr);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			System.<span class="keyword">out</span>.print(arr[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><p><code>直接选择排序</code>理解起来相对容易，平均时间复杂度为<code>O(n^2)</code>，<code>直接选择排序</code>在排序过程涉及到两个元素位置的交换，所以相同数值的元素的排列顺序很可能在交互过程发生改变，所以是一种<code>不稳定</code>的排序算法。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>进行 n 次选择，n 为待排序元素个数，每次选择即排好一个元素。    </p>
<p>示例待排序元素：【2，7，3，0】，下面高亮为已经排好序的。</p>
<ol>
<li>以上面待排序元素为例，首先选择第一个元素<code>2</code>，再从<code>2</code>后面所有元素中找出最小的元素，可通过依次比较每次存下最小值位置，遍历到最后发现<code>0</code>元素为最小元素，将<code>2</code>与<code>0</code>互相交换位置。目前序列为：【<code>0</code>，7，3，2】。</li>
<li>接着选择元素<code>7</code>，找出<code>7</code>后面最小元素，发现是<code>2</code>，<code>7</code>和<code>2</code>交换位置。目前序列为：【<code>0</code>，<code>2</code>，3，7】。</li>
<li>同理，直到选择到最后一个元素，排序结束。<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StraightChooseSort</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">chooseSort</span>(<span class="params"><span class="keyword">int</span> a[]</span>)</span>&#123;</div><div class="line">		<span class="keyword">int</span> n = a.length;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</div><div class="line">			<span class="keyword">int</span> k = i;<span class="comment">//记录a[i]到a[n-1]中找最小的元素的位置</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n;j++)&#123;</div><div class="line">				<span class="keyword">if</span>(a[j] &lt; a[k])</div><div class="line">					k = j;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//交换位置</span></div><div class="line">			<span class="keyword">if</span>(k != i)&#123;</div><div class="line">                <span class="keyword">int</span> tmp = a[i] ; </div><div class="line">                a[i] = a[k] ;  </div><div class="line">                a[k] = tmp; </div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		chooseSort(arr);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			System.<span class="keyword">out</span>.print(arr[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p><code>直接插入排序</code>理解起来也相对容易，平均时间复杂度为<code>O(n^2)</code>，<code>直接插入排序</code>在与前一个进行比较时，如果相等就排在其后面，所以是一种<code>稳定</code>的排序算法。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>进行 n-1 次插入，n 为待排序元素个数，每次插入即排好一个元素。    </p>
<p>示例待排序元素：【2，7，3，0】，下面高亮为已经排好序的。</p>
<ol>
<li>以上面待排序元素为例，首先从第二个元素<code>7</code>开始，先记下<code>7</code>这个值，然后与前一个元素<code>2</code>进行比较，发现<code>2</code>比自己小，不做移动。目前序列为：【<code>2</code>，<code>7</code>，3，0】。</li>
<li>接着从第三个元素<code>3</code>开始，先记下<code>3</code>这个值，与前一个元素<code>7</code>进行比较，发现<code>7</code>比<code>3</code>大，将<code>7</code>往后移动一个位置，即现在<code>7</code>在<code>3</code>的位置。接着再与前一个<code>2</code>比较，发现<code>2</code>比<code>3</code>小，不做移动，将<code>3</code>插入到<code>2</code>后面，即原先<code>7</code>的位置。目前序列为：【<code>2</code>，<code>3</code>，<code>7</code>，0】。</li>
<li>接着从第三个元素<code>0</code>开始，先记下<code>0</code>这个值，与前一个元素<code>3</code>进行比较，发现<code>3</code>比<code>0</code>大，将<code>3</code>往后移动一个位置；接着与前一个<code>7</code>进行比较，发现<code>7</code>比<code>0</code>大，将<code>7</code>往后移动一个位置；接着与前一个<code>2</code>进行比较，发现<code>2</code>比<code>0</code>大，将<code>2</code>往后移动一个位置。这时由于前面已经没有元素，所以把<code>0</code> 插入现在所在位置，即第一个。目前序列为：【<code>0</code>，<code>2</code>，<code>3</code>，<code>7</code>】。<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StraightInsertionSort</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] arr</span>)</span>&#123;</div><div class="line">		<span class="keyword">int</span> temp;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			<span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>])&#123;	<span class="comment">//从第二个开始，如果当前比前一个小</span></div><div class="line">				temp = arr[i];		<span class="comment">//记录要插入的值</span></div><div class="line">				<span class="keyword">int</span> j = i - <span class="number">1</span>;		<span class="comment">//从前一个开始</span></div><div class="line">				<span class="keyword">do</span>&#123;					<span class="comment">//依次往后移动一个位置</span></div><div class="line">					arr[j + <span class="number">1</span>] = arr[j];</div><div class="line">					j--;</div><div class="line">				&#125;<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp);<span class="comment">//当且仅当遇到的数都比要插入的数大</span></div><div class="line">				arr[j + <span class="number">1</span>] = temp;<span class="comment">//找到位置，插入</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		InsertSort(arr);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			System.<span class="keyword">out</span>.print(arr[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><code>希尔排序</code>又叫<code>缩小增量排序</code>，它是在<code>直接插入排序</code>的基础上，引入<code>增量</code>的做法，使得排序效率更高。时间复杂度约为<code>n的1.2次幂</code>，介于基本排序算法和高效排序算法间。由于<code>希尔排序</code>跳跃式的移动，使得值相同的元素可能被打乱顺序，因而它是不稳定排序。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><code>希尔排序</code>提出<code>缩小增量</code>的概念在于解决<code>直接插入排序</code>存在的问题：没一个元素在插入之前，都需要使大量被比较的元素移动位置。  </p>
<p>而<code>希尔排序</code>通过不断划分子序列并在子序列里进行直接排序，这样一来每个子序列相当于跨间隔进行比较，举个例子：按间隔为<code>10</code>划分后，可能第<code>1</code>个元素和第<code>10</code>个元素在同一个子序列，原先<code>直接插入排序</code>可能需要多次移动才能将第<code>1</code>个元素和第<code>10</code>个元素进行排序，现在跨间隔只需要1次。而经过多次缩小间隔划分后，所有元素会趋向于值小的在前面，值大的在后面，达到基本有序，这将有利于我们高效率地进行最后一次全体<code>直接插入排序</code>。  </p>
<p><code>缩小增量</code>基本思想是这样的：首先取一个整数<code>gap &lt; n</code>作为间隔（经试验，普遍认为<code>gap=(n/3)+1</code>效率比较高）将全部元素氛围<code>gap</code>个子序列，所以距离<code>gap</code>的元素放在同一个子序列，在每一个子序列分别施行<code>直接插入排序</code>，然后缩小间隔<code>gap</code>，重复子序列划分和排序，直到<code>gap==1</code>，所有元素在同一个序列。由于在排序后期，大多元素已经基本有序，所以排序速度仍然很快。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShellSort</span> &#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span>(<span class="params"><span class="keyword">int</span> a[]</span>)</span>&#123;</div><div class="line">		<span class="keyword">int</span> n = a.length;</div><div class="line">		<span class="keyword">int</span> gap = n;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">		<span class="keyword">do</span>&#123;</div><div class="line">			gap = gap/<span class="number">3</span> + <span class="number">1</span>;<span class="comment">//缩小间隔，直到间隔为1，进行全体直接插入排序</span></div><div class="line">	        <span class="keyword">for</span> (j = gap; j &lt; n; j++)&#123;<span class="comment">//从数组第 gap+1 个元素开始  </span></div><div class="line">	            <span class="keyword">if</span> (a[j] &lt; a[j - gap])<span class="comment">//每个元素与自己组内的数据进行直接插入排序  </span></div><div class="line">	            &#123;  </div><div class="line">	                <span class="keyword">int</span> temp = a[j];  </div><div class="line">	                <span class="keyword">int</span> k = j - gap;  </div><div class="line">	                <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; a[k] &gt; temp)  </div><div class="line">	                &#123;  </div><div class="line">	                    a[k + gap] = a[k];  </div><div class="line">	                    k -= gap;  </div><div class="line">	                &#125;  </div><div class="line">	                a[k + gap] = temp;  </div><div class="line">	            &#125; </div><div class="line">	        &#125;</div><div class="line">		&#125;<span class="keyword">while</span>(gap &gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		shellSort(arr);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			System.<span class="keyword">out</span>.print(arr[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><code>快速排序</code>是目前最通用的高效的内部排序算法，平均时间复杂度为<code>O(nlogn)</code>，一般情况下所需要的额外内存也是<code>O(nlogn)</code>，如果不考虑额外内存的消耗，通常使用快排，在大量随机数排序时，其表现最好。另外，快排是一种不稳定的排序。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p><code>快速排序</code>可以采用递归调用，每一次调用能对当前所有元素进行一次划分，保证在被选中的基本元素左边都是比它小的，右边都是比它大的。  </p>
<p>  如第一次我们选择所有元素的第一个元素作为基准元素，经过一次快排后，基准元素的位置可能变化到其他地方，但是此时可以保证的是在基准元素左边的都是比它小，在右边都是比它大的元素。这样一来，我们再对其左边的所有元素进行递归调用快排，右边的所有元素递归调用快排，最终就能完成排序。  </p>
<p>这里进行一次快排的步骤演示：示例待排序元素：【2，7，3，0，1，4】，高亮为已经排好序的元素，<code>&lt;</code>表示指针<code>left</code>，<code>&gt;</code>表示指针<code>right</code>。</p>
<ol>
<li>初始定义两个指针：<code>left</code>指向数组下标0，即第一个元素；<code>right</code>指针数组下标5，即最后一个元素。指针<code>left</code>往右移动，指针<code>right</code>往左移动。两指针相遇，表示全部元素已被遍历，完成一次快排。</li>
<li>首先选择第一个元素<code>2</code>作为<code>基准元素</code>，从右往左移动指针<code>right</code>，找第一个比它小的元素，找到元素<code>1</code>，移动元素<code>1</code>到指针<code>left</code>所在位置，即数组下标0的位置。现在指针<code>right</code>从右往左走到数组下标4的位置。当前排序情况为：【<code>1</code>&lt;，7，3，0，&gt;1，4】。</li>
<li>接着从左往右找比基准元素<code>2</code>大的元素(下文指的从左往右或从右往左即为排序情况中<code>&lt;&gt;</code>里的元素)，找到元素<code>7</code>，把元素<code>7</code>移动到指针<code>right</code>的位置，同时指针<code>left</code>向右移动一步走到数组下标1的位置。当前排序情况：【<code>1</code>，7&lt;，3，0，&gt;<code>7</code>，4】。</li>
<li>继续从右往左找比基准元素小的，找到元素<code>0</code>，于是把元素<code>0</code>移动到指针<code>left</code>所在位置，同时指针<code>right</code>向左走了一步走到数组下标3的位置。当前排序情况：【<code>1</code>，<code>0</code>&lt;，3，&gt;0，<code>7</code>，4】。</li>
<li>继续从左往右找比基准元素大的，找到元素<code>3</code>，于是把元素<code>3</code>移动到指针<code>right</code>所在位置，同时指针<code>left</code>向右走了一步走到数组小标4的位置。当前排序情况：【<code>1</code>，<code>0</code>，3&lt;，&gt;<code>3</code>，<code>7</code>，4】。</li>
<li>接着从右往左移动指针<code>right</code>，立即和<code>left</code>相遇，表示遍历结束，于是把基准元素<code>2</code>放到相遇的位置，即数组下标2。此时完成一次快排，基准元素<code>2</code>左边都比它小，右边都比它大。当前排序情况：【<code>1</code>，<code>0</code>，<code>2</code>&lt;&gt;，<code>3</code>，<code>7</code>，4】。</li>
<li>接着再对基准元素左边进行递归快排，同样右边元素也进行递归快排。</li>
</ol>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">quickSort</span>(int[] arr,int start,int end)&#123;</div><div class="line">		<span class="keyword">if</span>(start &gt;= end)	<span class="keyword">return</span>;</div><div class="line">		int <span class="keyword">left</span> = start;	<span class="comment">//当前这段数组最左端下标</span></div><div class="line">		int <span class="keyword">right</span> = end;		<span class="comment">//当前这段数组最右端下标</span></div><div class="line">		int standard = arr[start];		<span class="comment">//定义当前这段数组最左端元素为基准元素</span></div><div class="line">		</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;	<span class="comment">//left从左递增，right从右递减相遇了，说明所有元素都扫描过了。</span></div><div class="line">			<span class="comment">//从右往左找比基准值小的</span></div><div class="line">			<span class="keyword">while</span>(arr[<span class="keyword">right</span>] &gt;= standard &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</div><div class="line">				<span class="keyword">right</span>--;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;	<span class="comment">//如果没有找到，则left = right，说明基准元素右边都比他大，则不用替换。</span></div><div class="line">				arr[<span class="keyword">left</span>++] = arr[<span class="keyword">right</span>];	<span class="comment">//left++ 保证下一步从左往右找时从 left + 1 个找起，因为第i在本行已经被替换确认为是比基准元素小的</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">//从左往右找比基准值大的</span></div><div class="line">			<span class="keyword">while</span>(arr[<span class="keyword">left</span>] &lt;= standard &amp;&amp; <span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;		</div><div class="line">				<span class="keyword">left</span>++;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</div><div class="line">				arr[<span class="keyword">right</span>--] = arr[<span class="keyword">left</span>];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//此时left == right这个位置的值应该为基准值，且左边所有元素比它小，右边比它大。</span></div><div class="line">		arr[<span class="keyword">left</span>] = standard;</div><div class="line">		<span class="comment">//继续递归调用</span></div><div class="line">		<span class="built_in">quickSort</span>(arr, start, <span class="keyword">left</span>-<span class="number">1</span>);		<span class="comment">//对当前基准值左边元素排序</span></div><div class="line">		<span class="built_in">quickSort</span>(arr, <span class="keyword">right</span>+<span class="number">1</span>, end);		<span class="comment">//对当前基准值右边元素排序</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</div><div class="line">		int[] arr = new int[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		<span class="built_in">quickSort</span>(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</div><div class="line">		<span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			<span class="type">System</span>.out.<span class="built_in">print</span>(arr[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><code>堆排序</code>也是一种高效的内部排序算法，平均时间复杂度为<code>O(nlogn)</code>。由于其利用<code>堆</code>这一数据结构，所以实现起来相对麻烦一些；不过只要理解了<code>堆</code>，实际上<code>堆排序</code>算法非常简洁。由于<code>堆</code>结构经常需要向上或向下调整，所以<code>堆排序</code>也是一种不稳定排序。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p><strong>理解<code>堆排序</code>的重点在于理解<code>堆</code>，这里简要介绍下<code>堆</code>。</strong>  </p>
<p><code>堆</code>是一种特殊的完全二叉树，主要在于它的所有父节点都大于或小于子节点，所以堆也分为<code>最大堆</code>和<code>最小堆</code>。由于其根节点可以一直维持为所有最大或最小的元素，这种结构称为优先队列。在一些需要操作所有元素的最大或最小值时效率特别高。  </p>
<p>如在<code>最大堆</code>中取得最大值的时间复杂度为<code>O(1)</code>；而维持<code>最大堆</code>的时间复杂度也仅为<code>O(logn)</code>。</p>
<ol>
<li>利用这一特点，我们可以每次将根节点，即堆的最大值，与倒数第<code>(n-i)</code>个节点交换值（这里<code>n</code>为节点个数，<code>i</code>为已交换次数），这一步只需要<code>O(1)</code>的时间复杂度。但此时最大堆的特性已经被破坏，根节点不再是最大值了。</li>
<li>这时我们再调整为最大堆，这一步耗费<code>O(logn)</code>。</li>
<li>重复步骤 1，2 直到所有<code>(n == i</code>)，即所有结点都交换成功。此时从根节点开始遍历，就是完成的升序。  </li>
</ol>
<p><strong>所以最关键的算法就是调整堆为最大堆，做法如下：</strong></p>
<p>从根节点开始，与左右子结点进行比较，如果子结点比父节点大，则两结点交换，即把较大值向上调整，保持父节点始终比子节点大。接着再把被调整下来的原父节点继续与子结点进行比较和调整。一旦父节点比左右子节点大，则不再往下调整。</p>
<p>（设所有结点个数为<code>n</code>，当前结点为第<code>i</code>个结点，则左子树存在公式为：<code>（i * 2） &lt;= n</code>，同理右子数存在公式为：<code>（i * 2 + 1） &lt;= n</code>；如果是以数组存储堆的话，该公式改为：左子树存在公式为：<code>（i * 2 + 1） &lt;= （n - 1）</code>，同理右子数存在公式为：<code>（i * 2 + 2） &lt;= （n -）</code>，其中<code>i</code>为数组下标。）  </p>
<p><strong>而这一切的前提是最大堆已经建立成功，所以下面介绍下最大堆的建立：</strong></p>
<p>  这里有个做法能在O(n)的时间复杂度里完成最大堆的建立。首先有个元素数量为<code>n</code>的数组，我们知道完全二叉树的倒数第一个非叶子节点的位置为第<code>n/2</code>个，在数组中的下标为<code>n/2 - 1</code>。把大于这个下标的节点直接作为叶子节点开始进行建堆。然后从倒数第<code>n/2</code>个位置开始，进行最大堆调整，这时就能把倒数第<code>n/2</code>个位置的节点调整为具有最大值的父节点。同理，依次对倒数第<code>n/2 - 1</code>个、<code>n/2 - 2</code>个 … <code>1</code>个节点进行调整，最终就能得到整个最大堆。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] heap;<span class="comment">//用来存放堆的数组</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span>;<span class="comment">//用来存储堆中元素的个数</span></div><div class="line"></div><div class="line">	<span class="comment">//排序</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> heapSort()&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">count</span> &gt; <span class="number">1</span>)&#123;</div><div class="line">        		swap(<span class="number">0</span>,--<span class="keyword">count</span>);</div><div class="line">        		siftdown(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//向下调整函数</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> siftdown(<span class="keyword">int</span> i) <span class="comment">//传入一个需要向下调整的结点编号i，这里传入0，即从堆的顶点开始向下调整</span></div><div class="line">	&#123;</div><div class="line">	    <span class="keyword">int</span> maxIndex = <span class="number">0</span>;<span class="comment">//记录较大值的下标</span></div><div class="line">	    <span class="keyword">boolean</span> needSiftDown = <span class="keyword">true</span>;<span class="comment">//用来标记是否需要继续向下调整</span></div><div class="line">	    </div><div class="line">	    <span class="comment">//当节点有儿子且需要向下调整</span></div><div class="line">	    <span class="keyword">while</span>((i*<span class="number">2</span> + <span class="number">1</span>) &lt;= <span class="keyword">count</span><span class="number">-1</span> &amp;&amp; needSiftDown)</div><div class="line">	    &#123;        </div><div class="line">	        <span class="comment">//得到节点和其左儿子中较大的一个的下标</span></div><div class="line">	    		maxIndex = (heap[i] &lt; heap[(i*<span class="number">2</span> + <span class="number">1</span>)]) ? (i*<span class="number">2</span> + <span class="number">1</span>) : i;</div><div class="line">	        <span class="keyword">if</span>((i*<span class="number">2</span> + <span class="number">2</span>) &lt;= <span class="keyword">count</span><span class="number">-1</span>)<span class="comment">//如果有右儿子,再得到当前较大的下标</span></div><div class="line">	        		maxIndex = (heap[maxIndex] &lt; heap[(i*<span class="number">2</span> + <span class="number">2</span>)]) ? (i*<span class="number">2</span> + <span class="number">2</span>) : maxIndex;</div><div class="line">	        <span class="comment">//如果发现最大的结点编号不是自己，说明子结点中有比父结点更大的  </span></div><div class="line">	        <span class="keyword">if</span>(maxIndex != i)</div><div class="line">	        &#123;</div><div class="line">	            swap(maxIndex,i);<span class="comment">//交换</span></div><div class="line">	            i = maxIndex;<span class="comment">//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整</span></div><div class="line">	        &#125;</div><div class="line">	        <span class="keyword">else</span></div><div class="line">	        		needSiftDown = <span class="keyword">false</span>;<span class="comment">//则否说明当前的父结点已经比两个子结点都要大了，不需要在进行调整了</span></div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//建堆</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> creat()</div><div class="line">	&#123;</div><div class="line">	    <span class="comment">//从最后一个非叶结点到第1个结点依次进行向上调整</span></div><div class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="keyword">count</span>/<span class="number">2</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)</div><div class="line">	        siftdown(i);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//通过下标交换数组堆中两个元素值</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> swap(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</div><div class="line">	&#123;</div><div class="line">	    <span class="keyword">int</span> temp = heap[x];</div><div class="line">	    heap[x] = heap[y];</div><div class="line">	    heap[y] = temp;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//赋值时同时得到个数</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> setHeap(<span class="keyword">int</span>[] heap) &#123;</div><div class="line">		<span class="keyword">this</span>.heap = heap;</div><div class="line">		<span class="keyword">this</span>.<span class="keyword">count</span> = heap.length;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] getHeap() &#123;</div><div class="line">		<span class="keyword">return</span> heap;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		HeapSort hs = <span class="keyword">new</span> HeapSort();</div><div class="line">		hs.setHeap(arr);<span class="comment">// 设置待排序的数组</span></div><div class="line">		hs.creat();<span class="comment">//建堆</span></div><div class="line">		hs.heapSort();<span class="comment">//排序</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; hs.getHeap().length;i++)&#123;</div><div class="line">			System.out.print(hs.getHeap()[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><code>归并排序</code>是一种高效内部排序算法，与<code>快排</code>和<code>堆排序</code>相比它的优势在于：它是稳定的排序，并且性能与输入顺序无关，总是为<code>O(nlogn)</code>。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p><code>归并排序</code>采用<code>分治法</code>，将大问题不断化为更小的问题，直到小问题达到能够直接解决的程度，再向上不断合并小问题。  </p>
<p>如我们要对一个数组采用<code>归并排序</code>，我们不断地将它从中间划分成两个小数组，小数组再划分成小数组，直到小数组元素个数为1，能很方便地进行计算，就开始合并两个已经排好序的小数组，不断地向上合并，最终整个数组就是排好序的。  </p>
<p>所以现在关键在于对两个有序数组的合并。我们可以这么做：  </p>
<p>设有有序数组 <code>A</code>，<code>B</code>；以及临时合并数组 <code>C</code>。</p>
<p> 首先选取<code>A</code>、<code>B</code>数组中第一个元素较小的元素放入数组<code>C</code>中，假设拥有最小元素的数组为<code>A</code>数组。接着再从<code>A</code>数组中取第二个元素与<code>B</code>数组的第一个元素进行比较，谁小就放入<code>C</code>数组，不断重复这样的步骤，期间如果有一个数组为空，则直接把另一个数组后面元素全部放到<code>C</code>数组中，完成合并。  </p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MergeSort</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="params"><span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[]</span>)</span>&#123;</div><div class="line">	    <span class="keyword">if</span> (first &lt; last)  </div><div class="line">	    &#123;  </div><div class="line">	        <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;  </div><div class="line">	        sort(a, first, mid, temp);    <span class="comment">//左边有序 </span></div><div class="line">	        sort(a, mid+<span class="number">1</span>, last, temp); <span class="comment">//右边有序</span></div><div class="line">	        merge(a, first, mid, last, temp); <span class="comment">//再将两个有序数列合并  </span></div><div class="line">	    &#125;  </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span>(<span class="params"><span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[]</span>)  </span></div><div class="line">	&#123;  </div><div class="line">	    <span class="keyword">int</span> i = first;</div><div class="line">	    <span class="keyword">int</span> j = mid + <span class="number">1</span>; </div><div class="line">	    <span class="keyword">int</span> k = <span class="number">0</span>;  </div><div class="line">	    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= last)  </div><div class="line">	    &#123;  </div><div class="line">	        <span class="keyword">if</span> (a[i] &lt;= a[j])  </div><div class="line">	        		temp[k++] = a[i++];  </div><div class="line">	        <span class="keyword">else</span>  </div><div class="line">	        		temp[k++] = a[j++];   </div><div class="line">	    &#125;  </div><div class="line">	  </div><div class="line">	    <span class="keyword">while</span> (i &lt;= mid)  </div><div class="line">	        temp[k++] = a[i++];  </div><div class="line">	  </div><div class="line">	    <span class="keyword">while</span> (j &lt;= last)  </div><div class="line">	        temp[k++] = a[j++]; </div><div class="line">	    </div><div class="line">	    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)  <span class="comment">//回写</span></div><div class="line">	        a[first + i] = temp[i]; </div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</div><div class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</div><div class="line">		sort(arr, <span class="number">0</span>, arr.length<span class="number">-1</span>, temp);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</div><div class="line">			System.<span class="keyword">out</span>.print(arr[i] + <span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr>
<blockquote>
<p>《数据结构》殷人昆版<br><a href="http://blog.csdn.net/morewindows/article/details/6678165/" target="_blank" rel="external">白话经典算法系列之五 归并排序的实现</a><br><a href="http://blog.jobbole.com/101484/" target="_blank" rel="external">坐在马桶上看算法（12）：堆—神奇的优先队列</a></p>
</blockquote>
</div><script type="text/javascript" src="/js/share.js?v=0.0.2" async></script><a data-url="http://www.zhangzhiyong.xyz/2016/06/17/常用算法排序/" data-id="ciwuuuw1o000ajt8ztt2hp2ie" class="article-share-link">share</a><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-nav"><a href="/2016/06/13/ 设计模式-观察者/" class="next">设计模式-观察者</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.zhangzhiyong.xyz"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/观察者/" style="font-size: 15px;">观察者</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/工厂/" style="font-size: 15px;">工厂</a> <a href="/tags/策略/" style="font-size: 15px;">策略</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/常用算法排序/">常用排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/ 设计模式-观察者/">设计模式-观察者</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/设计模式-工厂/">设计模式-工厂</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/13/设计模式-策略/">设计模式-策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/网易2016Java实习生笔试题最后一题题解/">网易2016Java实习生笔试题最后一题题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/ java实现判断是否包含字符串方法/">java实现判断是否包含字符串方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/Move Zeroes/">Move Zeroes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/Product of Array Except Self/">Product of Array Except Self</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">张智勇的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.2"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>