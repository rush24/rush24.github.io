<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>设计模式-工厂 | 张智勇的博客</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">设计模式-工厂</h1><a id="logo" href="/.">张智勇的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">设计模式-工厂</h1><div class="post-meta">Jun 11, 2016<span> | </span><span class="category"><a href="/categories/设计模式/">设计模式</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简单工厂模式"><span class="toc-number">2.</span> <span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是简单工厂模式"><span class="toc-number">2.1.</span> <span class="toc-text">什么是简单工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用简单工厂模式"><span class="toc-number">2.2.</span> <span class="toc-text">为什么要用简单工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么用简单工厂模式"><span class="toc-number">2.3.</span> <span class="toc-text">怎么用简单工厂模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">3.</span> <span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是工厂方法模式"><span class="toc-number">3.1.</span> <span class="toc-text">什么是工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用工厂方法模式"><span class="toc-number">3.2.</span> <span class="toc-text">为什么要用工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么用工厂方法模式"><span class="toc-number">3.3.</span> <span class="toc-text">怎么用工厂方法模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">4.</span> <span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是抽象工厂模式"><span class="toc-number">4.1.</span> <span class="toc-text">什么是抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用抽象工厂模式"><span class="toc-number">4.2.</span> <span class="toc-text">为什么要用抽象工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怎么用抽象工厂模式"><span class="toc-number">4.3.</span> <span class="toc-text">怎么用抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单工厂模式-1"><span class="toc-number">5.1.</span> <span class="toc-text">简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">5.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">5.1.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景"><span class="toc-number">5.1.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工厂方法模式-1"><span class="toc-number">5.2.</span> <span class="toc-text">工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象工厂模式-1"><span class="toc-number">5.3.</span> <span class="toc-text">抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点-2"><span class="toc-number">5.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点-2"><span class="toc-number">5.3.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适用场景-2"><span class="toc-number">5.3.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><hr>
<p>工厂模式实际上包含<code>简单工厂</code>、<code>工厂方法</code>、<code>抽象工厂</code>三种设计模式，其中<code>简单工厂</code>模式并不在 GOF23 种设计模式中，由于其使用频率较高，也通常被称为一种入门的设计模式。本篇将会不惜篇幅循序渐进展开三种设计模式之间的关联和推进，达到更好的理解和使用。  </p>
<p>而三种工厂模式设计目的均是为了解决对象的创建问题，所以工厂模式也属于创建型模式。在不使用工厂模式时，我们的代码通过将对象的创建和使用写在一处，这种做法将违反<code>单一职责</code>和<code>开闭原则</code>，不利于代码的重用和维护，稍后我们会详细解释。  </p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><hr>
<h2 id="什么是简单工厂模式"><a href="#什么是简单工厂模式" class="headerlink" title="什么是简单工厂模式"></a>什么是简单工厂模式</h2><p>简单工厂模式，也叫静态工厂方法，是由一个工厂对象决定创建出哪一种产品类的实例<br>即我们把原来跟对象的使用耦合在一起的代码提炼出一个专门负责创建对象的工厂，转而通过调用工厂方法来得到对象。  </p>
<h2 id="为什么要用简单工厂模式"><a href="#为什么要用简单工厂模式" class="headerlink" title="为什么要用简单工厂模式"></a>为什么要用简单工厂模式</h2><p>让我们来看定一份披萨通常是什么样：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//披萨店类</span></div><div class="line"><span class="keyword">Public</span> class PizzaStore&#123;</div><div class="line"></div><div class="line">	<span class="keyword">Public</span> Pizza orderPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</div><div class="line">		Pizza pizza = <span class="built_in">NULL</span>；</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(<span class="keyword">type</span>.<span class="keyword">equals</span>(<span class="string">"chicken"</span>))&#123;</div><div class="line">			pizza = <span class="literal">new</span> ChickenPizza();</div><div class="line">		&#125;esle <span class="keyword">if</span>(<span class="keyword">type</span>.<span class="keyword">equals</span>(<span class="string">"vegetables"</span>))&#123;</div><div class="line">			pizza = <span class="literal">new</span> VegetablesPizza();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="comment">//pizza = ...</span></div><div class="line">		&#125;</div><div class="line">		<span class="comment">//还可能对pizza对象做一些初始化工作</span></div><div class="line"></div><div class="line">		<span class="comment">//执行切片、打包等过程</span></div><div class="line">		pizza.cut();</div><div class="line">		pizza.box;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里我们将<code>Pizza</code>对象的创建和使用耦合在一起，这样有什么坏处呢？首先便是违反了<code>单一职责</code>，一个方法没有只做一件事，而且很有可能其他地方也需要用到<code>Pizza</code>对象的创建和初始化，不利于代码的复用；其次，如果我们需要添加新的<code>Pizza</code>种类，或者需要更改初始化代码，那么就需要在<code>if...else</code>中不断更改，违反了<code>开闭原则</code>。   </p>
<h2 id="怎么用简单工厂模式"><a href="#怎么用简单工厂模式" class="headerlink" title="怎么用简单工厂模式"></a>怎么用简单工厂模式</h2><p>而如果我们将对象的创建和初始化代码封装在工厂方法中，需要的时候我们直接调用工厂方法获取<strong>生产</strong>出的对象实例。一旦需要增改，只需要在工厂方法中更改一份，其他用到对象创建的地方就都生效了。 就像这样：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//披萨店类</span></div><div class="line"> <span class="keyword">Public</span> class PizzaStore&#123;</div><div class="line"></div><div class="line">	SimpleFactory simpleFactory;</div><div class="line"></div><div class="line">	<span class="keyword">Public</span> PizzaStore(SimpleFactory simpleFactory)&#123;</div><div class="line">		this.simpleFactory = simpleFactory;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">Public</span> Pizza orderPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</div><div class="line">		Pizza pizza = <span class="built_in">NULL</span>;</div><div class="line">		pizza = simpleFactory.createPizza(<span class="keyword">type</span>);</div><div class="line"></div><div class="line">		<span class="comment">//执行切片、打包等过程</span></div><div class="line">		pizza.cut();</div><div class="line">		pizza.box();</div><div class="line"></div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//披萨工厂类</span></div><div class="line"><span class="keyword">Public</span> class SimpleFactory&#123;</div><div class="line">	<span class="comment">//通过这个方法得当Pizza对象实例</span></div><div class="line">	<span class="keyword">Public</span> Pizza createPizza(<span class="built_in">String</span> <span class="keyword">type</span>)&#123;</div><div class="line">		Pizza pizza = <span class="built_in">NULL</span>；</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(<span class="keyword">type</span>.<span class="keyword">equals</span>(<span class="string">"chicken"</span>))&#123;</div><div class="line">			pizza = <span class="literal">new</span> ChickenPizza();</div><div class="line">		&#125;esle <span class="keyword">if</span>(<span class="keyword">type</span>.<span class="keyword">equals</span>(<span class="string">"vegetables"</span>))&#123;</div><div class="line">			pizza = <span class="literal">new</span> VegetablesPizza();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="comment">//pizza = ...</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//还可能对pizza对象做一些初始化工作</span></div><div class="line"></div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，定一份披萨无需关心披萨如何被生产的，只需要告诉工厂要哪种披萨，甚至后期可通过<code>XML</code>描述文件来进行软编码，达到不用重新编译即可新增披萨种类。这其实很类似于<code>Spring</code>框架的<code>IOC</code>原理，你只需要描述对象是如何创建的，通过注解或<code>XML</code>形式配置，使用时传入配置类名对应的简称，<code>IOC</code>容器就会通过<code>BeanFactory</code>创建并返回对应的实例。但其实<code>IOC</code>的实现更像是下面介绍的 工厂方法模式，因为它还有多个具体工厂。   </p>
<p> 在实际开发中，我们还可以视情况选择在工厂中利用反射达到对象的创建，从而避免增改工厂方法中<code>if...else</code>逻辑代码。  </p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><hr>
<h2 id="什么是工厂方法模式"><a href="#什么是工厂方法模式" class="headerlink" title="什么是工厂方法模式"></a>什么是工厂方法模式</h2><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<h2 id="为什么要用工厂方法模式"><a href="#为什么要用工厂方法模式" class="headerlink" title="为什么要用工厂方法模式"></a>为什么要用工厂方法模式</h2><p>简单工厂模式中我们只有一个工厂类，用来生成产品（对象实例），但是当新增产品时，不可避免的要去修改工厂类中生成产品的代码，即上文的<code>if...else</code> 逻辑判断代码，这实际上违背了<code>开闭原则</code>。<br>而工厂方法则是提取抽象工厂类，并增加了具体工厂实现类，来实现当新增产品时，无需修改原先封装的抽象工厂类，只需要新加一个生产该产品的具体工厂实现类。  </p>
<h2 id="怎么用工厂方法模式"><a href="#怎么用工厂方法模式" class="headerlink" title="怎么用工厂方法模式"></a>怎么用工厂方法模式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//披萨店工厂抽象类</span></div><div class="line"><span class="type">Public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">	<span class="comment">//该方法提供给外界使用，通过让外界直接调用业务方法，隐藏工厂方法</span></div><div class="line">	<span class="type">Public</span> <span class="keyword">final</span> <span class="type">Pizza</span> orderPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)</span>&#123;</div><div class="line">		<span class="type">Pizza</span> pizza = <span class="type">NULL</span>;</div><div class="line">		pizza = createPizza(<span class="class"><span class="keyword">type</span>)</span>;</div><div class="line"></div><div class="line">		<span class="comment">//执行切片、打包等过程</span></div><div class="line">		pizza.cut();</div><div class="line">		pizza.box;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//通过这个方法得当Pizza对象实例</span></div><div class="line">	<span class="keyword">abstract</span> <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//披萨工厂具体实现类1</span></div><div class="line"><span class="type">Public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateStore1</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">	<span class="type">Public</span> <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)</span>&#123;</div><div class="line">		<span class="type">Pizza</span> pizza = <span class="type">NULL</span>；</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">equals</span>(<span class="params">"chicken"</span>))</span>&#123;</div><div class="line">			pizza = <span class="keyword">new</span> <span class="type">ChickenPizza</span>();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="comment">//pizza = ...</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//还可能对pizza对象做一些初始化工作</span></div><div class="line"></div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//披萨工厂具体实现类2</span></div><div class="line"><span class="type">Public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreateStore2</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>&#123;</div><div class="line">	public <span class="type">Pizza</span> createPizza(<span class="type">String</span> <span class="class"><span class="keyword">type</span>)</span>&#123;</div><div class="line">		<span class="type">Pizza</span> pizza = <span class="type">NULL</span>；</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(<span class="class"><span class="keyword">type</span>.<span class="title">equals</span>(<span class="params">"vegetables"</span>))</span>&#123;</div><div class="line">			pizza = <span class="keyword">new</span> <span class="type">VegetablesPizza</span>();</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			<span class="comment">//pizza = ...</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//还可能对pizza对象做一些初始化工作</span></div><div class="line"></div><div class="line">		<span class="keyword">return</span> pizza;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//模拟客户端调用</span></div><div class="line">public static void main(<span class="type">String</span> args[]) &#123; </div><div class="line">	<span class="type">PizzaStore</span> pizzaStore = <span class="keyword">new</span> <span class="type">ConcreateStore1</span>();<span class="comment">//可引入配置文件实现</span></div><div class="line">	<span class="type">Pizza</span> pizza = pizzaStore.orderPizza(<span class="string">"chicken"</span>);</div><div class="line">	pizza.eat();<span class="comment">//这里就是 Pizza 类提供的方法了，如吃披萨</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  代码中的<code>PizzaStore</code>就是工厂抽象类，你也可以把这个类名改为 <code>PizzaFactory</code>，把其工厂实现类如<code>ConcreateStore1</code>改为 <code>ConcreatePizzaFactory1</code>。    </p>
<p>  并且我们在抽象类<code>PizzaStore</code>中加了一个<code>orderPizza</code>的业务方法，并设为不可变防止子类重写，在这个方法里调用<code>createPizza</code>实现<code>Pizza</code>对象的创建和初始化。一次来对客户端进行隐藏，客户端只要调用<code>orderPizza</code>这个业务方法即可。当然，你也可以不要这个方法，直接调用<code>createPizza</code>方法。  </p>
<p>  由于我们是针对接口编程（接口可范指 Java 中的接口和抽象类），而不是对具体的实现类。所以我们总是可以通过调用接口的<code>orderPizza</code>方法来达到，并传入想要的口味来得到披萨，即便现在新增了一家“必胜客”披萨店，我只要实现 <code>PizzaStore</code>的<code>createPizza</code>方法，其他都不用修改， 就能吃到必胜客的鸡肉味披萨。当然此时客户端代码第一行需要改为：<code>PizzaStore pizzaStore = new PizzaHut();</code>  </p>
<p>但实际上这行代码我们也可以通过读取配置文件，通过更改配置文件来实现不同工厂的热拔插。  </p>
<p>我们可以发现工厂方法模式的一个特点，让子类（工厂具体实习类）真正实现工厂方法并创建对象，因此如果增加实现类，工厂抽象类并不知道，但客户端确是通过抽象类去调用的，从而达到将对象的使用和创建解耦。这实际上符合<code>依赖倒置</code>原则 —— <code>抽象不应该依赖于细节，细节应当依赖于抽象</code>。    </p>
<p><code>依赖倒置</code>原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。  </p>
<p>一般情况我们的披萨店由于需要制作不同口味披萨，会依赖于这些不同的披萨类，但是当我们对其进行倒置时，转为披萨店依赖于披萨抽象接口，而不依赖具体披萨类。而具体类的对象则是通过<code>依赖注入</code>的方式注入到依赖它的对象中去。常用的注入方式有三种，分别是：<code>构造注入</code>，<code>设值注入（Setter注入）</code>和<code>接口注入</code>。是不是觉得<code>工厂方法模式</code>很像 <code>Spring IOC</code>的实现？ </p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><hr>
<h2 id="什么是抽象工厂模式"><a href="#什么是抽象工厂模式" class="headerlink" title="什么是抽象工厂模式"></a>什么是抽象工厂模式</h2><p> 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。<br> 与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p>
<h2 id="为什么要用抽象工厂模式"><a href="#为什么要用抽象工厂模式" class="headerlink" title="为什么要用抽象工厂模式"></a>为什么要用抽象工厂模式</h2><p>让我们引入这样一个问题：在<code>工厂方法模式</code>中，每增加一种产品就需要实现其对应的工厂，会导致增加许多类。    </p>
<p>我们前面介绍的不同披萨工厂生产不同的风味的披萨，但都只是披萨这个单一产品。比如必胜客这个生产披萨的工厂（餐厅）如果只生产披萨就太浪费了，如果我们新加一种产品——意面，那不是得专门为其开一间必胜客意面店？但我们知道实际上必胜客的招牌不仅有披萨还有意面等等产品，这一系列必胜客制作的叫<code>产品族</code>，如果我们的<code>抽象工厂模式</code>也能像必胜客一样，能够生产相关产品族而不需要新增工厂就太好了，而实际上也确实就是这么做的。    </p>
<p>也就是说，抽象工厂模式很适合生产一组产品，比如在开发中经常需要为一组产品提供不同的主题，此时增换主题只需要增换工厂即可。  </p>
<h2 id="怎么用抽象工厂模式"><a href="#怎么用抽象工厂模式" class="headerlink" title="怎么用抽象工厂模式"></a>怎么用抽象工厂模式</h2><pre><code>//工厂抽象类
Public abstract class Factory{
    abstract Pizza createPizza(String type);
    abstract Noodle createNoodle(String type);
}

//必胜客工厂具体实现类
Public class PizzaHutFactory extends Factory{
    Public Pizza createPizza(String type){
        Pizza pizza = NULL；

        if(type.equals(&quot;chicken&quot;)){
            pizza = new ChickenPizza();
        }else{
            //pizza = ...
        }

        //还可能对pizza对象做一些初始化工作

        return pizza;
    }

    Public Noodle createNoodle(String type){
        Noodle noodle = NULL；

        if(type.equals(&quot;chicken&quot;)){
            noodle = new ChickenNoodle();
        }else{
            //noodle = ...
        }

        //还可能对noodle对象做一些初始化工作

        return noodle;
    }
}

//必败客工厂具体实现类
Public class anotherFactory extends Factory{
    public Pizza createPizza(String type){
        Pizza pizza = NULL；

        if(type.equals(&quot;vegetables&quot;)){
            pizza = new VegetablesPizza();
        else{
            //pizza = ...
        }

        //还可能对pizza对象做一些初始化工作

        return pizza;
    }

    Public Noodle createNoodle(String type){
        Noodle noodle = NULL；

        if(type.equals(&quot;vegetables&quot;)){
            noodle = new ChickenNoodle();
        }else{
            //noodle = ...
        }

        //还可能对noodle对象做一些初始化工作

        return noodle;
    }
}

public static void main(String args[]) { 
    //实例化必胜客工厂(只要一个工厂就能得到一系列该工厂生成的产品)
    Factory factory = new PizzaHutFactory();    
    Pizza pizza = factory.create(&quot;chicken&quot;);//一份必胜客鸡肉味披萨
    Noodle noodle = factory.create(&quot;chicken&quot;);//一份必胜客鸡肉味意面
    pizza.eat();
    noodle.eat();
}
</code></pre><p>可以发现，<code>抽象工厂模式</code>在生产系列产品时很方便，不论是从工厂类的数量还是从客户端使用时的配置。如果我们要为这些产品族再新增一个主题，或者说新开一家西餐店，只要实现抽象工厂中的方法，其他什么地方均不用更改。  </p>
<p> 但是<code>抽象工厂模式</code>也有其缺点，比如想要新增一个产品，就需要更改抽象工厂，已经实现的具体工厂，还有客户端代码，<code>抽象工厂模式</code>的这种性质称为<code>开闭原则</code>的倾斜性。所以它通常更适合在需要一起使用一系列产品的时候。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<h2 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>将对象的创建和使用分离，保证方法的单一职能，利于代码复用，引入工厂做到一处修改，处处生效。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>增改产品时，需要修改工厂方法里的逻辑代码，不利于维护。  </p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>工厂类需要创建的对象数量较少。</p>
<h2 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>新增产品时，只需要新加一个工厂具体实现类，无需修改原有代码；客户端在适用时，无需关心创建细节，甚至是产品类名。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>一个产品对应一个工厂，导致工厂数目增多，尤其在同时适用系列产品时更为明显。  </p>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>其实就是解决简单工厂中的问题，使其变得利于扩展和维护。</p>
<h2 id="抽象工厂模式-1"><a href="#抽象工厂模式-1" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>同时使用系列产品时，增加新的工厂很方便，客户端使用也只需创建一个工厂。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a><strong>缺点</strong></h3><p>新增产品而不是产品族，需要修改大量代码。  </p>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><p>例如我们需要对一套UI控件（产品族）提供不同的主题，不论是新增主题还是设置主题都很方便。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.2" async></script><a data-url="http://www.zhangzhiyong.xyz/2016/06/11/设计模式-工厂/" data-id="ciwxf6gi0000d5w8zmrklnkgy" class="article-share-link">share</a><div class="tags"><a href="/tags/设计模式/">设计模式</a><a href="/tags/工厂/">工厂</a></div><div class="post-nav"><a href="/2016/06/13/ 设计模式-观察者/" class="pre">设计模式-观察者</a><a href="/2016/04/13/设计模式-策略/" class="next">设计模式-策略</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.zhangzhiyong.xyz"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/观察者/" style="font-size: 15px;">观察者</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/工厂/" style="font-size: 15px;">工厂</a> <a href="/tags/策略/" style="font-size: 15px;">策略</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/常用算法排序/">常用排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/ 设计模式-观察者/">设计模式-观察者</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/11/设计模式-工厂/">设计模式-工厂</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/13/设计模式-策略/">设计模式-策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/网易2016Java实习生笔试题最后一题题解/">网易2016Java实习生笔试题最后一题题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/ java实现判断是否包含字符串方法/">java实现判断是否包含字符串方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/Move Zeroes/">Move Zeroes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/Product of Array Except Self/">Product of Array Except Self</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">张智勇的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.2"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>